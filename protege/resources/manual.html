<html>

<head>
  <title>XML2OWL Plugin</title>
</head>

<body style="width:700px">

  <h1 align="center">XML2OWL Plugin:</h1>
  <h2 align="center">Mapping new XML data to existing OWL ontologies</h2>

  <h3>Introduction</h3>

  The XML2OWL plugin allows for the semi-automatic mapping of XML data
  to an existing OWL ontology. New individuals and associated
  assertions are added based on pre-existing classes and
  properties. The mappings are determined by user-specified rules
  according to a particular XML schema.

  This plugin is particularly intended for when the user wants to
  integrate lots of data from one or more sources into the same OWL
  ontology, wants to have control over how the mapping is carried
  out, and is comfortable writing a basic XML document (unless someone
  else has already written one for him).

  <h3>Usage example</h3>

  Suppose that you run an online bookstore and want to store your data
  in book and author data in an OWL repository. You already have your
  OWL ontology structure defined, and you have an agreement with five
  different publishers to send you new book information on a regular
  basis in XML. You would like to automate the automatic mapping of
  the incoming data into your OWL ontology while allowing each
  publisher to send XML data according to their own XML schema. Once
  you have prepared 5 rule mapping files (one for each publisher), you
  could then use the XML2OWL plugin to automatically map the data
  into your ontology every time you get a new data file from one of
  the publishers.

  The figures below give a partial example. Figure 1 shows the book
  class in your pre-existing ontology in Protege. Figure 2 gives an
  example of a short datafile from the publisher Penguin. Figure 3
  lists a rule file which maps the datafiles from Penguin to your
  ontology, and Figure 4 shows one of the new individuals resulting
  from this example mapping.

  OWL ontology:

  <ul>
    <li>Classes
      <ul>
        <li>book
        <li>contributor
      </ul>
    <li>Data properties
      <ul>
        <li>hasTitle
        <li>hasPublisher
        <li>hasYear
      </ul>
    <li>Object properties
      <ul>
        <li>hasAuthor
        <li>hasEditor
      </ul>
  </ul>

  Example data:

  <xmp>
    <books>
      <book>
        <isbn>0034223427</isbn>
        <contributor role="author">James Joyce</contributor>
        <title>Ulysses</title>
        <publisher>Penguin</publisher>
        <year>2010</year>
      </book>
      <book>
        <isbn>4324324999</isbn>
        <author>Albert Camus</author>
        <title>The outsider</title>
        <publisher>Vintage</publisher>
        <year>2007</year>
      </book>
      <book>
        <isbn>8342432877</isbn>
        <author>Leo Tolstoy</author>
        <title>War and peace</title>
        <publisher>Penguin</publisher>
        <year>2012</year>
      </book>
      <book>
        <isbn>7432432239</isbn>
        <author>Albert Camus</author>
        <title>The pest</title>
        <publisher>Dover</publisher>
        <year>2001</year>
      </book>
    </books>
</xmp>

  <h3>Overview</h3>

  XML2OWL rules documents must adhere to the <a href="rules.xsd">rules
  XML schema</a>. This section describes the meaning and relationships
  of the elements of a rules document in detail.

  Rules document contain different kinds of elements.  Most of a rules
  document consists of mapping rules, of course. There are distinct
  rule types for the different kinds of OWL axioms: individual
  definitions, class assertions, data property assertions, object
  property assertions, same individual assertions, and different
  assertions. In addition, special rules are provided to allow for
  reusing new individuals across multiple rules (individual
  references) and for grouping individuals from multiple definitions
  together (individual collections). Finally, there are elements for
  defining XML namepaces and a global prefix IRI.<p/>

  <h3>Top level</h3>

  The top-level element under which all other elements are included is
  the &lt;ontologyMappingElements&gt; element. This element also has
  an optional <i>strict</i> attribute, which indicates whether the
  mapping should abort if minor errors are encountered (if "true"), or
  merely skip problematic rules (if "false", the default). It then has
  optional configuration elements followed by an arbitrary number of
  mapping rules.

  <ul>
    <li>&lt;ontologyMappingElement&gt;: top-level element
      <ul>
        <li><i>strict</i>: boolean (default: "false")
        <li>configuration elements: namespace definitions and global
        prefix IRI setting
        <li>rule elements: mapping rules for individual
        definitions/references/collections, class assertions, data and
        object property assertions, and same and different individual
        assertions
      </ul>
  </ul>

  <h3>Configuration elements</h3>

  Configuration elements consist of namespace declarations in the
  &lt;namespaces&gt; element and a global prefix IRI setting in the
  &lt;prefixIRI&gt; element. All configuration elements are optional.

  <h4>Namespaces</h4>
  
  An optional &lt;namespaces&gt; element can define any number of
  namespaces. Namespaces should be defined for the extra namespaces
  which appear in the XPath queries and expressions ("fn" is
  pre-included) and XML data documents.

  <ul>
    <li>&lt;namespaces&gt;: set of namespace declarations
      <ul>
        <li>&lt;namespace&gt; (1 or more): namespace declaration
          <ul>
            <li><i>prefix</i>: namespace prefix.
            <li><i>name</i>: namespace name.
          </ul>
      </ul>
  </ul>

  <h4>Prefix IRI</h4> 

  An optional &lt;prefixIRI&gt; element can be used to define a
  default prefix to be prepended to the OWL entity IRIs generated
  during rule processing. The element has a boolean <i>dynamic</i>
  attribute, which indicates whether it is static or dynamic. If
  static (the default), it is a literal string. If dynamic, it should
  specify an XPath expression which will yield the prefix when
  evaluated against the XML data's root node. 

  <ul>
    <li>&lt;prefixIRI&gt;: string or XPath expression
      <ul>
        <li><i>dynamic</i>: boolean (default "false")
        </li>
      </ul>
  </ul>

  <h3>Mapping rules</h3>

  The structure of the axiom rules have roughly the same
  template. First of all, they specify key attributes, such as
  individual reference names or flags indicating whether a property
  assertion is positive or negative. Second, they define mapping
  parts, with one mapping part for each part of an axiom. For example,
  a data property assertion has 3 mapping parts: one for the
  individual in question, one for the property name, and one for the
  property value. Third, there may be dependencies between the mapping
  parts. For instance, the same class assertion rule may result in
  different classes for different individuals, if it defines the class
  mapping part as dependent on the individual mapping part. <p/>

  The general template for a mapping part consists of three parts: a
  query, a prefix, and an expression. The optional query specifies an
  XPath query which identifies the nodes from the incoming XML
  document that correspond to that part. If the query is included,
  then the prefix and expression are XPath expressions evaluated
  against the nodes obtained from the query. For each node, the two
  results are then concatenated to dynamically produce the IRI of the
  OWL axiom part corresponding to the mapping part. If the query is
  ommitted, then the prefix and expression are static strings, which
  are concatenated to define onex IRI. The prefix is also optional; if
  it is ommitted, the prefix is obtained from the global prefix,
  defined separately. Note that although this is the general template
  for a mapping part, some types of mapping parts deviate from it a
  little, such as a data property value part, which doesn't result in
  an IRI (details below).<p/>

  <ul>
    <li id="mappingPart">mapping part
      <ul>
        <li id="query">&lt;query&gt; (optional): XPath query.
        <li id="prefixIRI">&lt;prefixIRI&gt;: XPath expression (with
          query) or literal string (with no query).
        <li id="expression">&lt;expression&gt;: XPath expression (with
          query) or literal string (with no query).
      </ul>
  </ul>

  In the case of individual definition mapping parts, it is also
  possible to use instead a reference to a previously defined
  individual definition mapping part. This allows for the reuse of the
  same individual definition mapping part over multiple rules. In this
  case, instead of providing an inline part with query, prefix and
  expression, a reference is inserted, identified by a reference
  name. See below for details. <p/>

  By default, mapping part queries are executed relative to the
  incoming document's root node. However, mapping part dependencies
  allow for the queries of one mapping part to depend on another
  (e.g., the class of an individual may depend on XML data attached to
  that individual). Dependencies specify a dependent part and an
  independent part, and the possible values depend on the rule type.
  During mapping, the independent query is processed first, and then
  the dependent part is processed relative to each resulting node from
  the independent query. Note that an individual reference cannot be
  used as the dependent part of a dependency, because its IRI has
  already been determined earlier.<p/>

  <ul>
    <li id="dependency">&lt;dependency&gt;: mapping part dependency
      <ul>
        <li><i>independent</i>: the independent mapping part of the dependency
        <li><i>dependent</i>: the dependent mapping part of the dependency
      </ul>
  </ul>

  <h4 id="individualPart">Individual parts</h4>
  
  Individual mapping parts can be either individual definitions or
  individual references. References refer to either individual
  definitions or collections of individual references.<p/>

  <h5 id="individualDefinition">Individual definitions</h5>
  
  OWL individuals can be defined either through a separate one-part
  mapping rule or inline within a larger mapping rule. In the former
  case, they are defined with the &lt;mapToOWLIndividual&gt; element,
  while in the latter, the name depends on the part and the rule
  (please see the sections below for details).<p/>

  The rule structure follows the mapping part template given above
  with the following adjustments. First, if the &lt;query&gt; element
  is provided, then the &lt;expression&gt; element is optional. In
  this case, an automatic unique naming mechanism is used to generate
  a unique IRI for each node resulting from the query. Second, the
  rule has a <i>type</i> attribute, which can specify that the
  individual is expected to be new to the ontology ("new"), that it
  exists already ("exists") or that it is unknown at design time
  whether it is new or existing ("unknown", the default). The mapping
  program will generate errors if the value is inconsistent with what
  is found in the ontology. Third, the rule can
  have <i>referenceName</i> attribute. If provided, the name can then
  be used in subsequent rules to refer to the same individuals.<p/>

  <ul>
    <li>&lt;mapToOWLIndividual&gt;: <a href="#mappingPart">mapping
    part</a> with following adjustments:
      <ul>
        <li><i>referenceName</i> (optional): reference name for the
          individuals
        <li><i>type</i> (optional): "new", "existing" or "unknown"
        (default)
        <li><a href="#expression">&lt;expression&gt;</a>: optional if
          the <a href="#query">&lt;query&gt;</a> is specified; in this
          case, the IRI is generated automatically.
      </ul>
  </ul>
  
  <h6>Examples</h6>

  <xmp>
    <mapToOWLIndividual referenceName="booksDynamic" type="new">
      <query>/books/book[fn:matches(isbn,'^[0-9X]{10}?$')]</query>
      <expression>fn:concat('isbn',isbn)</expression>
    </mapToOWLIndividual>

    <mapToOWLIndividual referenceName="bookCrimeAndPunishment">
      <expression>'isbn0343223423'</expression>
    </mapToOWLIndividual>

  </xmp>

  Individual definitions added to the OWL ontology:

  <ul>
    <li>'isbn0034223427'
    <li>'isbn4324324999'
    <li>'isbn8342432877'
    <li>'isbn7432432239'
    <li>'isbn0343223423'
  </ul>

  <h5 id="individualReference">Individual references</h5>

  Individual definitions can be reused across different rules if they
  are given a reference name the first time. In that case, they can be
  used in place of inline individual definitions inside larger mapping
  rules. The name of the reference element depends on the particular
  rule type (see specific rule types below for details). The only
  constraint is that they cannot serve as the dependent parts of a
  mapping dependency, since their IRIs were already determined upon
  definition.

  <ul>
    <li>individual reference element
      <ul>
        <li><i>refName</i>: name of an
        earlier individual <a href="#individualDefinition">definition</a>
        or <a href="#individualCollection">collection</a>.
      </ul>
  </ul>

  <h6>Example</h6>

  <xmp>
    <referenceToIndividual refName="booksDynamic"/>
  </xmp>

  This results in no direct changes in the ontology.

  <h5 id="individualCollection">Collections of individuals</h5>

  The &lt;collectOWLIndividuals&gt; element can be used to gather an
  arbitrary number of individual (or, recursively, collection)
  references under one reference name. It must be defined separately
  (not inline). (mention something about other potential complications
  and implications concerning dependencies, types, etc.) 

  <ul>
    <li>&lt;collectOWLIndividuals&gt;
      <ul>
        <li><i>referenceName</i>: reference name for the set of
          individuals contained in all the references listed
        <li>&lt;referenceToIndividual&gt; (1 or more):
          <a href="#individualReference">reference</a> to a previous
          individual <a href="#individualdefinition">definition</a> or
          <a href="#individualCollection">collection</a>.
      </ul>
  </ul>

  <h6>Example</h6>

  <xmp>
    <collectOWLIndividuals referenceName="books">
      <referenceToIndividual refName="booksDynamic"/>
      <referenceToIndividual refName="bookCrimeAndPunishment"/>
    </collectOWLIndividuals>
  </xmp>

  This results in no direct changes to the ontology

  <h4>Class assertions</h4>

  Class assertions are added with the &lt;mapToOWLClassAssertion&gt;
  element. The element contains an individual part and a class
  part. At least one of the parts must be dynamic. <p/>

  The individual part can be specified with either the inline
  &lt;individual&gt; element or the reference
  &lt;referenceToIndividual&gt; element.

  The class part is based directly on the mapping part template and
  has the name &lt;class&gt;.

  If a dependency is specified between the parts, the parts are
  referred to as "individual" and "class".

  <ul>
    <li>&lt;mapToOWLClassAssertion&gt;
      <ul>
        <li>&lt;individual&gt/&lt;referenceToIndividual&gt;:
        <a href="#individualPart">individual part</a>
        <li>&lt;class&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;dependency&gt; (optional): 
          <a href="#dependency">dependency</a> 
          (allowed parts: "individual", "class")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLClassAssertion>
      <referenceToIndividual refName="books"/>
      <class>
        <expression>'Book'</expression>
      </class>
    </mapToOWLClassAssertion>
  </xmp>

  Class assertions added to the OWL ontology:

  <ul>
    <li>Book('isbn0034223427')
    <li>Book('isbn4324324999')
    <li>Book('isbn8342432877')
    <li>Book('isbn7432432239')
    <li>Book('isbn0343223423')
  </ul>

  <h4>Data property assertions</h4>

  Data property assertions are added with the
  &lt;mapToOWLDataPropertyAssertion&gt; element. The element contains
  an individual part, a property name part and a property value
  part. At least one of the parts must be dynamic. <p/>

  The optional <i>type</i> attribute specifies whether the assertion
  is "positive" (the default) or "negative".

  The individual part can be specified with either the inline
  &lt;individual&gt; element or the reference
  &lt;referenceToIndividual&gt; element.

  The data property name part is based directly on the mapping part
  template and has the name &lt;propertyName&gt;.

  The data property value part is based on the mapping part
  template. However, data property values are not OWL individuals, but
  rather basic XML datatypes. Therefore, there are two
  adjustments. First, the mapping part has no &lt;prefixIRI&gt;
  element. Second, the optional <i>type</i> attribute specifies the
  XML datatype for the value. Supported values include "xsd:string"
  (the default), "xsd:boolean", "xsd:double", "xsd:float", and
  "xsd:integer". If used, the "xsd" namespace should be defined in
  the rules file as "http://www.w3.org/2001/XMLSchema".
  
  If dependencies are specified between any pair of parts, the parts
  are referred to as "individual", "propertyName" and
  "propertyValue". It is possible to specify up to two dependencies.

  <ul>
    <li>&lt;mapToOWLDataPropertyAssertion&gt;
      <ul>
        <li><i>type</i>: "positive" (the default) or "negative"
        <li>&lt;individual&gt;/&lt;referenceToIndividual&gt;: 
          <a href="#individualPart">individual part</a>
        <li>&lt;propertyName&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;propertyValue&gt;: <a href="#mappingPart">mapping
        part</a>, with the following adjustments:
          <ul>
            <li><i>type</i> (optional): the value datatype: allowed
            values are "xsd:string" (default), "xsd:boolean",
            "xsd:double", "xsd:float", "xsd:integer"
            <li><a href="#prefixIRI">&lt;prefixIRI&gt;</a>: omitted
          </ul>
        <li>&lt;dependency&gt; (optional, up to 2): 
          <a href="#dependency">dependency</a> 
          (allowed parts: "individual", "propertyName", "propertyValue")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLDataPropertyAssertion>
      <referenceToIndividual refName="booksDynamic"/>
      <propertyName>
        <expression>'hasYear'</expression>
      </propertyName>
      <propertyValue>
        <query>.</query>
        <expression type="xsd:integer">year</expression>
      </propertyValue>
      <dependency independent="individual" dependent="propertyValue"/>
    </mapToOWLDataPropertyAssertion>
  </xmp>

  Data property assertions added to the OWL ontology:

  <ul>
    <li>hasYear('isbn0034223427',2010)
    <li>hasYear('isbn4324324999',2007)
    <li>hasYear('isbn8342432877',2012)
    <li>hasYear('isbn7432432239',2001)
  </ul>

  <h4>Object property assertions</h4>

  Object property assertions are added with the
  &lt;mapToOWLObjectPropertyAssertion&gt; element. The element
  contains a domain individual part, a property name part and a range
  individual part. At least one of the parts must be dynamic. <p/>

  The optional <i>type</i> attribute specifies whether the assertion
  is "positive" (the default) or "negative".

  The domain individual part can be specified with either the inline
  &lt;domainIndividual&gt; element or the reference
  &lt;referenceToDomainIndividual&gt; element.

  The object property name part is based directly on the mapping part
  template and has the name &lt;propertyName&gt;.

  The range individual part can be specified with either the inline
  &lt;rangeIndividual&gt; element or the reference
  &lt;referenceToRangeIndividual&gt; element.

  If dependencies are specified between any pair of parts, the parts
  are referred to as "individual", "propertyName" and "propertyValue"
  (as for data property assertions). It is possible to specify up to
  two dependencies.

  <ul>
    <li>&lt;mapToOWLObjectPropertyAssertion&gt;
      <ul>
        <li><i>type</i>: "positive" (the default) or "negative"
        <li>&lt;domainIndividual&gt;/&lt;referenceToDomainIndividual&gt;:
          <a href="#individualPart">individual part</a>
        <li>&lt;propertyName&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;rangeIndividual&gt;/&lt;referenceToRangeIndividual&gt;:
          <a href="#individualPart">individual part</a> 
        <li>&lt;dependency&gt; (optional, up to 2): 
          <a href="#dependency">dependency</a>
          (allowed parts: "individual", "propertyName", "propertyValue")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLObjectPropertyAssertion>
      <domainIndividual referenceName="contributors">
        <query>contributor</query>
        <expression>fn:concat('contributor',fn:tokenize(.,'\s+')[last()])</expression>
      </domainIndividual>
      <propertyName>
        <query>@role</query>
        <expression>fn:concat('has',.)</expression>
      </propertyName>
      <referenceToRangeIndividual refName="books"/>
      <dependency independent="propertyValue" dependent="individual"/>
      <dependency independent="individual" dependent="propertyName"/>
    </mapToOWLObjectPropertyAssertion>
    
    <mapToOWLClassAssertion>
      <referenceToIndividual refName="contributors"/>
      <class>
        <expression>'Contributor'</expression>
      </class>
    </mapToOWLClassAssertion>

  </xmp>

  Individual definitions added to the OWL ontology, if they don't
  exist yet:

  <ul>
    <li>'contributorJamesJoyce'
    <li>'contributorAlbertCamus'
    <li>'contributorLeoTolstoy'

  Object property assertions added to the OWL ontology:

  <ul>
    <li>hasAuthor('isbn0034223427','contributorJamesJoyce')
    <li>hasEditor('isbn4324324999','contributorAlbertCamus')
    <li>hasEditor('isbn4324324999','contributorLeoTolstoy')
    <li>hasEditor('isbn7432432239','contributorAlbertCamus')
  </ul>

  Class assertions added to the OWL ontology:

  <ul>
    <li>Contributor('contributorJamesJoyce')
    <li>Contributor('contributorAlbertCamus')
    <li>Contributor('contributorLeoTolstoy')
  </ul>

  <h4>Same/Different individual assertions</h4>

  Same individual assertions and different individual assertions have
  an identical internal structure and are added with the
  &lt;mapToOWLSameAssertion&gt; and &lt;mapToOWLDifferentAssertion&gt;
  elements, respectively. Such an element can contain either one or
  two individual definition mapping parts or references. If it
  contains one part, all the individuals are asserted to be same as
  (or different from) each other. If it contains two parts, the
  individuals from one part are asserted to be same as (or different
  from) the individuals in the second part (this could be useful if a
  dependency is used).

  The first individual part is required, and is specified with either
  the inline &lt;individual1&gt; element or the reference
  &lt;referenceToIndividual1&gt; element.

  The second individual part is optional, and is specified with either
  the inline &lt;individual2&gt; element or the reference
  &lt;referenceToIndividual2&gt; element.

  If there are two parts and a dependency is specified between the
  parts, the parts are referred to as "individual1" and "individual2".

  <ul>
    <li>&lt;mapToOWLSameAssertion&gt;
      <ul>
        <li>&lt;individual1&gt;/&lt;referenceToIndividual1&gt;: 
          <a href="#individualPart">individual part</a>
        <li>&lt;individual2&gt;/&lt;referenceToIndividual2&gt;
          (optional): 
          <a href="#individualPart">individual part</a>
        <li>&lt;dependency&gt; (optional):
          <a href="#dependency">dependency</a>
          (allowed mapping part values: "individual1", "individual2")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLDifferentAssertion>
      <referenceToIndividual1 refName="books"/>
    </mapToOWLDifferentAssertion>
  </xmp>

  Different individual assertions added to the ontology (if not there already):

  <ul>
    <li>differentIndividuals('isbn0034223427','isbn4324324999','isbn8342432877','isbn7432432239','isbn0343223423')
  </ul>

  <h4>Summary</h4>

</body>

</html>
