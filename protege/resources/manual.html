<html>

<head>

  <title>XML2OWL Protégé Plugin</title>

  <style type="text/css">
    xmp { font-size : 15px}
  </style>

</head>

<body style="width:700px">

  <h1 align="center">XML2OWL Plugin for Protégé:</h1>
  <h2 align="center">Mapping new XML data to existing OWL ontologies</h2>

  <ul>
    <li><a href="#intro">Introduction</a></li>
    <li><a href="#interface">User interface</a></li>
    <li><a href="#usage">Use case</a></li>
    <ul>
      <li><a href="#ontology">OWL ontology</a></li>
      <li><a href="#sample">Sample datafile</a></li>
    </ul>
    <li><a href="#top">Top level</a></li>
    <li><a href="#configuration">Configuration elements</a></li>
    <ul>
      <li><a href="#namespaces">Namespaces</a></li>
      <li><a href="#prefix">Prefix IRI</a></li>
    </ul>
    <li><a href="#rules">Mapping rules</a></li>
    <ul>
      <li><a href="#individualPart">Individual parts</a></li>
      <ul>
        <li><a href="#individualDefinition">Individual definitions</a></li>
        <li><a href="#individualReference">Individual references</a></li>
        <li><a href="#individualCollection">Collections of individuals</a></li>
      </ul>
      <li><a href="#classAssertion">Class assertions</a></li>
      <li><a href="#dataPropertyAssertion">Data property assertions</a></li>
      <li><a href="#objectPropertyAssertion">Object property assertions</a></li>
      <li><a href="#identityAssertion">Same/different individual assertions</a></li>
    </ul>
  </ul>

  <h3 id="intro">Introduction</h3>

  <p>The XML2OWL plugin for Protégé allows for the semi-automatic
  mapping of XML data to an existing OWL ontology. New individuals and
  associated assertions are added based on pre-existing classes and
  properties. The mappings are determined by user-specified rules
  according to the <a href="rules.xsd">XML2OWL rules schema</a>.</p>

  <p>Rule documents contain different kinds of elements.  Most of a
  rules document consists of mapping rules, of course. There are
  distinct rule types for the different kinds of OWL axioms:
  individual definitions, class assertions, data property assertions,
  object property assertions, same individual assertions, and
  different assertions. In addition, special rules are provided to
  allow for reusing new individuals across multiple rules (individual
  references) and for grouping individuals from multiple definitions
  together (individual collections). Finally, there are elements for
  defining XML namepaces and a global prefix IRI.<p/>

  <p>The plugin is particularly suitable for when the user needs to
  integrate lots of data from one or more sources into the same OWL
  ontology, wants to have control over how the mapping is carried out,
  and is comfortable writing a basic XML document (unless someone else
  has already written one for him).</p>

  <h3 id="usage">Use case</h3>

  <p>Suppose that you run an online bookstore and want to store your
  data in book and author data in an OWL repository. You already have
  your OWL ontology structure defined, and you have an agreement with
  five different publishers to send you new book information on a
  regular basis in XML. You would like to automate the automatic
  mapping of the incoming data into your OWL ontology while allowing
  each publisher to send XML data according to their own XML
  schema. Once you have prepared 5 rule mapping files (one for each
  publisher), you could then use the XML2OWL plugin to automatically
  map the data into your ontology every time you get a new data file
  from one of the publishers.</p>

  <p>The examples given in this manual are based on this scenario.
  Specifically, the next two subsections outline a simple OWL book
  ontology and an example of incoming XML data.</p>

  <h4 id="ontology">OWL ontology</h4>

  The simple ontology below contains two classes, three data
  properties and two object properties. New mappings will result in
  new individuals in the ontology, along with class, data property and
  object property assertions.

  <ul>
    <li>Classes
      <ul>
        <li>Book
        <li>Contributor
      </ul>
    <li>Data properties
      <ul>
        <li>hasTitle
        <li>hasPublisher
        <li>hasYear
      </ul>
    <li>Object properties
      <ul>
        <li>hasAuthor
        <li>hasEditor
      </ul>
  </ul>

  <h4 id="sample">Sample datafile</h4>

  Here is a short sample datafile that might be received by the online
  bookstore and need to be mapped into the OWL ontology.

  <xmp>
    <?xml version="1.0" encoding="UTF-8"?>
    <books xmlns:shop="http://www.shop.com">
      <shop:source>Amazon</shop:source>
      <book>
        <isbn>0034223427</isbn>
        <contributor role="author">James Joyce</contributor>
        <title>Ulysses</title>
        <publisher>Penguin</publisher>
        <year>2010</year>
      </book>
      <book>
        <isbn>4324324999</isbn>
        <contributor role="author">Albert Camus</contributor>
        <title>The outsider</title>
        <publisher>Vintage</publisher>
        <year>2007</year>
      </book>
      <book>
        <isbn>8342432877</isbn>
        <contributor role="editor">Steve Nichols</contributor>
        <title>The collected works of James Joyce</title>
        <publisher>Penguin</publisher>
        <year>2012</year>
      </book>
      <book>
        <isbn>7432432239</isbn>
        <contributor role="author">Albert Camus</contributor>
        <title>The pest</title>
        <publisher>Dover</publisher>
        <year>2001</year>
      </book>
    </books>
  </xmp>

  <h3 id="interface">User interface</h3>

  The XML2OWL mapper window (accessible through the XML2OWL tab) has
  three areas: Rules, Data and Control. After the contents of a rules
  file and data file are put into the Rules and Data areas,
  respectively, the Control area initiates the mapping and the OWL
  ontology is updated accordingly.

  The contents of a rules file are pasted into the Rules
  textarea. They can be typed or pasted manually, or the Open button
  can be used to insert the contents of a file from the
  filesystem. The rules file can then be validated against
  the <a href="rules.xsd">XML2OWL rules schema</a> with the Validate
  button (this is not necessary, however, as it happens anyway as the
  first step in mapping).

  The contents of a data file are pasted into the Data textarea in
  exactly the same way as for the rules.

  The Control area has two buttons. When the Map button is clicked,
  the mapping program applies the rules to the data and adds the
  resulting new individuals and assertions to the OWL ontology. The
  last mapping can be undone by clicking on the Undo button.

  <h3 id="top">Top level</h3>

  The top-level element under which all other elements are included is
  the &lt;ontologyMappingElements&gt; element. This element also has
  an optional <i>strict</i> attribute, which indicates whether the
  mapping should abort if minor errors are encountered (if "true"), or
  merely skip problematic rules (if "false", the default). It then has
  optional configuration elements followed by an arbitrary number of
  mapping rules.

  <ul>
    <li>&lt;ontologyMappingElement&gt;: top-level element
      <ul>
        <li><i>strict</i>: boolean (default: "false")
        <li>configuration elements: namespace definitions and global
        prefix IRI setting
        <li>rule elements: mapping rules for individual
        definitions/references/collections, class assertions, data and
        object property assertions, and same and different individual
        assertions
      </ul>
  </ul>

  <h3 id="configuration">Configuration elements</h3>

  Configuration elements consist of namespace declarations in the
  &lt;namespaces&gt; element and a global prefix IRI setting in the
  &lt;prefixIRI&gt; element. All configuration elements are optional.

  <h4 id="namespaces">Namespaces</h4>
  
  An optional &lt;namespaces&gt; element can define any number of
  namespaces. Namespaces should be defined for the extra namespaces
  which appear in the XPath queries and expressions ("fn" is
  pre-included) and XML data documents.

  <ul>
    <li>&lt;namespaces&gt;: set of namespace declarations
      <ul>
        <li>&lt;namespace&gt; (1 or more): namespace declaration
          <ul>
            <li><i>prefix</i>: namespace prefix.
            <li><i>name</i>: namespace name.
          </ul>
      </ul>
  </ul>

  <h5 id="namespaces-example">Example</h5>

  <xmp>
    <namespaces>
      <namespace prefix="shop" name="http://www.myshop.com">
    </namespaces>
  </xmp>

  <h4 id="prefix">Prefix IRI</h4> 

  An optional &lt;prefixIRI&gt; element can be used to define a
  default prefix to be prepended to the OWL entity IRIs generated
  during rule processing. The element has a boolean <i>dynamic</i>
  attribute, which indicates whether it is static or dynamic. If
  static (the default), it is a literal string. If dynamic, it should
  specify an XPath expression which will yield the prefix when
  evaluated against the XML data's root node. 

  <ul>
    <li>&lt;prefixIRI&gt;: string or XPath expression
      <ul>
        <li><i>dynamic</i>: boolean (default "false")
      </ul>
  </ul>

  <h5 id="prefix-example">Example</h5>

  <xmp>
    <prefixIRI dynamic="true">
      fn:concat('http://www.myshop.com/',/books/shop:source,'#')
    </prefixIRI>
  </xmp>

For our example, this would result in a default prefix IRI of<br/>
"http://www.myshop.com/Amazon#".

  <h3 id="rules">Mapping rules</h3>

  The structure of the axiom rules have roughly the same
  template. First of all, they specify key attributes, such as
  individual reference names or flags indicating whether a property
  assertion is positive or negative. Second, they define mapping
  parts, with one mapping part for each part of an axiom. For example,
  a data property assertion has 3 mapping parts: one for the
  individual in question, one for the property name, and one for the
  property value. Third, there may be dependencies between the mapping
  parts. For instance, the same class assertion rule may result in
  different classes for different individuals, if it defines the class
  mapping part as dependent on the individual mapping part. <p/>

  The general template for a mapping part consists of three parts: a
  query, a prefix, and an expression. The optional query specifies an
  XPath query which identifies the nodes from the incoming XML
  document that correspond to that part. If the query is included,
  then the prefix and expression are XPath expressions evaluated
  against the nodes obtained from the query. For each node, the two
  results are then concatenated to dynamically produce the IRI of the
  OWL axiom part corresponding to the mapping part. If the query is
  ommitted, then the prefix and expression are static strings, which
  are concatenated to define one IRI. The prefix is also optional; if
  it is ommitted, the prefix is obtained from
  the <a href="#prefix">global prefix</a>. Note that although this is
  the general template for a mapping part, some types of mapping parts
  deviate slightly from it. These deviations are described in the
  rule-specific sections that follow.<p/>

  <ul>
    <li id="mappingPart">mapping part
      <ul>
        <li id="query">&lt;query&gt; (optional): XPath query.
        <li id="prefixIRI">&lt;prefixIRI&gt;: XPath expression (with
          query) or literal string (with no query).
        <li id="expression">&lt;expression&gt;: XPath expression (with
          query) or literal string (with no query).
      </ul>
  </ul>

  In the case of individual definition mapping parts, it is also
  possible to use instead
  a <a href="#individualReference">reference</a> to a previously
  defined individual definition mapping part. This allows for the
  reuse of the same individual definition mapping part over multiple
  rules. In this case, instead of providing an inline part with query,
  prefix and expression, a reference is inserted, identified by a
  reference name. See below for details. <p/>

  By default, mapping part queries are executed relative to the
  incoming document's root node. However, mapping part dependencies
  allow for the queries of one mapping part to depend on another
  (e.g., the class of an individual may depend on XML data attached to
  that individual). Dependencies specify a dependent part and an
  independent part, and the possible values depend on the rule type
  (as explained in the rule-specific sections.  During mapping, the
  independent query is processed first, and then the dependent part is
  processed relative to each resulting node from the independent
  query. Note that an individual reference cannot be used as the
  dependent part of a dependency, because its IRI has already been
  determined earlier.<p/>

  <ul>
    <li id="dependency">&lt;dependency&gt;: mapping part dependency
      <ul>
        <li><i>independent</i>: the independent mapping part of the dependency
        <li><i>dependent</i>: the dependent mapping part of the dependency
      </ul>
  </ul>

  <h4 id="individualPart">Individual parts</h4>
  
  Individual mapping parts can be either individual definitions or
  individual references. References refer to either individual
  definitions or collections of individual references. This section
  describes individual definitions, references and collections
  further.<p/>

  <h5 id="individualDefinition">Individual definitions</h5>
  
  OWL individuals can be defined either through a separate one-part
  mapping rule or inline within a larger mapping rule. In the former
  case, they are defined with the &lt;mapToOWLIndividual&gt; element,
  while in the latter, the name depends on the part and the rule
  (please see the sections below for details).<p/>

  The rule structure follows the mapping part template given above
  with the following adjustments. First, if the &lt;query&gt; element
  is provided, then the &lt;expression&gt; element is optional. In
  this case, an automatic unique naming mechanism is used to generate
  a unique IRI for each node resulting from the query. Second, the
  rule has a <i>type</i> attribute, which can specify that the
  individual is expected to be new to the ontology ("new"), that it
  exists already ("exists") or that it is unknown at design time
  whether it is new or existing ("unknown", the default). The mapping
  program will generate errors if the value is inconsistent with what
  is found in the ontology. Third, the rule can have
  a <i>referenceName</i> attribute. If provided, the name can then be
  used in subsequent rules to refer to the same individuals.<p/>

  <ul>
    <li>&lt;mapToOWLIndividual&gt;: <a href="#mappingPart">mapping
    part</a> with following adjustments:
      <ul>
        <li><i>referenceName</i> (optional): reference name for the
          individuals
        <li><i>type</i> (optional): "new", "existing" or "unknown"
        (default)
        <li><a href="#expression">&lt;expression&gt;</a>: optional if
          the <a href="#query">&lt;query&gt;</a> is specified; in this
          case, the IRI is generated automatically.
      </ul>
  </ul>
  
  <h6 id="individualDefinition-examples">Examples</h6>

  <xmp>
    <mapToOWLIndividual referenceName="booksDynamic" type="new">
      <query>/books/book[fn:matches(isbn,'^[0-9X]{10}?$')]</query>
      <expression>fn:concat('isbn',isbn)</expression>
    </mapToOWLIndividual>

    <mapToOWLIndividual referenceName="bookCrimeAndPunishment">
      <expression>'isbn0343223423'</expression>
    </mapToOWLIndividual>

  </xmp>

  Individual definitions added to the OWL ontology:

  <ul>
    <li>'isbn0034223427'
    <li>'isbn4324324999'
    <li>'isbn8342432877'
    <li>'isbn7432432239'
    <li>'isbn0343223423'
  </ul>

  <h5 id="individualReference">Individual references</h5>

  Individual definitions can be reused across different rules if they
  are given a reference name the first time. In that case, they can be
  used in place of inline individual definitions inside larger mapping
  rules. The name of the reference element depends on the particular
  rule type (see specific rule types below for details). The only
  constraint is that they cannot serve as the dependent parts of a
  mapping dependency, since their IRIs were already determined upon
  definition.

  <ul>
    <li>individual reference element
      <ul>
        <li><i>refName</i>: name of an
        earlier individual <a href="#individualDefinition">definition</a>
        or <a href="#individualCollection">collection</a>.
      </ul>
  </ul>

  <h6 id="individualDefinition-example">Example</h6>

  <xmp>
    <referenceToIndividual refName="booksDynamic"/>
  </xmp>

  This results in no direct changes in the ontology.

  <h5 id="individualCollection">Collections of individuals</h5>

  The &lt;collectOWLIndividuals&gt; element can be used to gather an
  arbitrary number of individual (or, recursively, collection)
  references under one reference name. It must be defined separately
  (not inline). 

  If a collection is used as an independent part in a dependency and
  contains a mix of static and dynamic references, any static
  references will be skipped when processing the dependent part.

  <ul>
    <li>&lt;collectOWLIndividuals&gt;
      <ul>
        <li><i>referenceName</i>: reference name for the set of
          individuals contained in all the references listed
        <li>&lt;referenceToIndividual&gt; (1 or more):
          <a href="#individualReference">reference</a> to a previous
          individual <a href="#individualdefinition">definition</a> or
          <a href="#individualCollection">collection</a>.
      </ul>
  </ul>

  <h6 id="individualCollection-example">Example</h6>

  <xmp>
    <collectOWLIndividuals referenceName="books">
      <referenceToIndividual refName="booksDynamic"/>
      <referenceToIndividual refName="bookCrimeAndPunishment"/>
    </collectOWLIndividuals>
  </xmp>

  This results in no direct changes to the ontology.

  <h4 id="classAssertion">Class assertions</h4>

  Class assertions are added with the &lt;mapToOWLClassAssertion&gt;
  element. The element contains an individual part and a class
  part. At least one of the parts must be dynamic. <p/>

  The individual part can be specified with either the inline
  &lt;individual&gt; element or the reference
  &lt;referenceToIndividual&gt; element.

  The class part is based directly on the mapping part template and
  has the name &lt;class&gt;.

  If a dependency is specified between the parts, the parts are
  referred to as "individual" and "class".

  <ul>
    <li>&lt;mapToOWLClassAssertion&gt;
      <ul>
        <li>&lt;individual&gt/&lt;referenceToIndividual&gt;:
        <a href="#individualPart">individual part</a>
        <li>&lt;class&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;dependency&gt; (optional): 
          <a href="#dependency">dependency</a> 
          (allowed parts: "individual", "class")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLClassAssertion>
      <referenceToIndividual refName="books"/>
      <class>
        <expression>'Book'</expression>
      </class>
    </mapToOWLClassAssertion>
  </xmp>

  Class assertions added to the OWL ontology:

  <ul>
    <li>Book('isbn0034223427')
    <li>Book('isbn4324324999')
    <li>Book('isbn8342432877')
    <li>Book('isbn7432432239')
    <li>Book('isbn0343223423')
  </ul>

  <h4 id="dataPropertyAssertion">Data property assertions</h4>

  Data property assertions are added with the
  &lt;mapToOWLDataPropertyAssertion&gt; element. The element contains
  an individual part, a property name part and a property value
  part. At least one of the parts must be dynamic. <p/>

  The optional <i>type</i> attribute specifies whether the assertion
  is "positive" (the default) or "negative".

  The individual part can be specified with either the inline
  &lt;individual&gt; element or the reference
  &lt;referenceToIndividual&gt; element.

  The data property name part is based directly on the mapping part
  template and has the name &lt;propertyName&gt;.

  The data property value part is based on the mapping part
  template. However, data property values are not OWL individuals, but
  rather basic XML datatypes. Therefore, there are two
  adjustments. First, the mapping part has no &lt;prefixIRI&gt;
  element. Second, the optional <i>type</i> attribute specifies the
  XML datatype for the value. Supported values include "xsd:string"
  (the default), "xsd:boolean", "xsd:double", "xsd:float", and
  "xsd:integer". If used, the "xsd" namespace should be defined in
  the rules file as "http://www.w3.org/2001/XMLSchema".
  
  If dependencies are specified between any pair of parts, the parts
  are referred to as "individual", "propertyName" and
  "propertyValue". It is possible to specify up to two dependencies.

  <ul>
    <li>&lt;mapToOWLDataPropertyAssertion&gt;
      <ul>
        <li><i>type</i>: "positive" (the default) or "negative"
        <li>&lt;individual&gt;/&lt;referenceToIndividual&gt;: 
          <a href="#individualPart">individual part</a>
        <li>&lt;propertyName&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;propertyValue&gt;: <a href="#mappingPart">mapping
        part</a>, with the following adjustments:
          <ul>
            <li><i>type</i> (optional): the value datatype: allowed
            values are "xsd:string" (default), "xsd:boolean",
            "xsd:double", "xsd:float", "xsd:integer"
            <li><a href="#prefixIRI">&lt;prefixIRI&gt;</a>: omitted
          </ul>
        <li>&lt;dependency&gt; (optional, up to 2): 
          <a href="#dependency">dependency</a> 
          (allowed parts: "individual", "propertyName", "propertyValue")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLDataPropertyAssertion>
      <referenceToIndividual refName="booksDynamic"/>
      <propertyName>
        <expression>'hasYear'</expression>
      </propertyName>
      <propertyValue>
        <query>.</query>
        <expression type="xsd:integer">year</expression>
      </propertyValue>
      <dependency independent="individual" dependent="propertyValue"/>
    </mapToOWLDataPropertyAssertion>
  </xmp>

  Data property assertions added to the OWL ontology:

  <ul>
    <li>hasYear('isbn0034223427',2010)
    <li>hasYear('isbn4324324999',2007)
    <li>hasYear('isbn8342432877',2012)
    <li>hasYear('isbn7432432239',2001)
  </ul>

  <h4 id="objectPropertyAssertion">Object property assertions</h4>

  Object property assertions are added with the
  &lt;mapToOWLObjectPropertyAssertion&gt; element. The element
  contains a domain individual part, a property name part and a range
  individual part. At least one of the parts must be dynamic. <p/>

  The optional <i>type</i> attribute specifies whether the assertion
  is "positive" (the default) or "negative".

  The domain individual part can be specified with either the inline
  &lt;domainIndividual&gt; element or the reference
  &lt;referenceToDomainIndividual&gt; element.

  The object property name part is based directly on the mapping part
  template and has the name &lt;propertyName&gt;.

  The range individual part can be specified with either the inline
  &lt;rangeIndividual&gt; element or the reference
  &lt;referenceToRangeIndividual&gt; element.

  If dependencies are specified between any pair of parts, the parts
  are referred to as "individual", "propertyName" and "propertyValue"
  (as for data property assertions). It is possible to specify up to
  two dependencies.

  <ul>
    <li>&lt;mapToOWLObjectPropertyAssertion&gt;
      <ul>
        <li><i>type</i>: "positive" (the default) or "negative"
        <li>&lt;domainIndividual&gt;/&lt;referenceToDomainIndividual&gt;:
          <a href="#individualPart">individual part</a>
        <li>&lt;propertyName&gt;: <a href="#mappingPart">mapping part</a>
        <li>&lt;rangeIndividual&gt;/&lt;referenceToRangeIndividual&gt;:
          <a href="#individualPart">individual part</a> 
        <li>&lt;dependency&gt; (optional, up to 2): 
          <a href="#dependency">dependency</a>
          (allowed parts: "individual", "propertyName", "propertyValue")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLObjectPropertyAssertion>
      <domainIndividual referenceName="contributors">
        <query>contributor</query>
        <expression>fn:concat('contributor',fn:tokenize(.,'\s+')[last()])</expression>
      </domainIndividual>
      <propertyName>
        <query>@role</query>
        <expression>fn:concat('has',fn:upper-case(fn:substring(.,1,1)),fn:substring(.,2))</expression>
      </propertyName>
      <referenceToRangeIndividual refName="books"/>
      <dependency independent="propertyValue" dependent="individual"/>
      <dependency independent="individual" dependent="propertyName"/>
    </mapToOWLObjectPropertyAssertion>
    
    <mapToOWLClassAssertion>
      <referenceToIndividual refName="contributors"/>
      <class>
        <expression>'Contributor'</expression>
      </class>
    </mapToOWLClassAssertion>

  </xmp>

  Individual definitions added to the OWL ontology, if they don't
  exist yet:

  <ul>
    <li>'contributorJamesJoyce'
    <li>'contributorAlbertCamus'
    <li>'contributorSteveNichols'

  Object property assertions added to the OWL ontology:

  <ul>
    <li>hasAuthor('isbn0034223427','contributorJamesJoyce')
    <li>hasAuthor('isbn4324324999','contributorAlbertCamus')
    <li>hasEditor('isbn4324324999','contributorSteveNichols')
    <li>hasAuthor('isbn7432432239','contributorAlbertCamus')
  </ul>

  Class assertions added to the OWL ontology:

  <ul>
    <li>Contributor('contributorJamesJoyce')
    <li>Contributor('contributorAlbertCamus')
    <li>Contributor('contributorSteveNichols')
  </ul>

  <h4 id="identityAssertion">Same/Different individual assertions</h4>

  Same individual assertions and different individual assertions have
  an identical internal structure and are added with the
  &lt;mapToOWLSameAssertion&gt; and &lt;mapToOWLDifferentAssertion&gt;
  elements, respectively. Such an element can contain either one or
  two individual definition mapping parts or references. If it
  contains one part, all the individuals are asserted to be same as
  (or different from) each other. If it contains two parts, the
  individuals from one part are asserted to be same as (or different
  from) the individuals in the second part (this could be useful if a
  dependency is used).

  The first individual part is required, and is specified with either
  the inline &lt;individual1&gt; element or the reference
  &lt;referenceToIndividual1&gt; element.

  The second individual part is optional, and is specified with either
  the inline &lt;individual2&gt; element or the reference
  &lt;referenceToIndividual2&gt; element.

  If there are two parts and a dependency is specified between the
  parts, the parts are referred to as "individual1" and "individual2".

  <ul>
    <li>&lt;mapToOWLSameAssertion&gt;
      <ul>
        <li>&lt;individual1&gt;/&lt;referenceToIndividual1&gt;: 
          <a href="#individualPart">individual part</a>
        <li>&lt;individual2&gt;/&lt;referenceToIndividual2&gt;
          (optional): 
          <a href="#individualPart">individual part</a>
        <li>&lt;dependency&gt; (optional):
          <a href="#dependency">dependency</a>
          (allowed parts: "individual1", "individual2")
      </ul>
  </ul>

  <h5>Example</h5>

  <xmp>
    <mapToOWLDifferentAssertion>
      <referenceToIndividual1 refName="books"/>
    </mapToOWLDifferentAssertion>
  </xmp>

  Different individual assertions added to the ontology (if not there already):

  <ul>
    <li>differentIndividuals('isbn0034223427','isbn4324324999','isbn8342432877','isbn7432432239','isbn0343223423')
  </ul>

</body>

</html>
